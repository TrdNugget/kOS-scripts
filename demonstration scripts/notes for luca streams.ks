/me LOG "IF NOT SHIP:UNPACKED AND SHIP:LOADED { WAIT UNTIL SHIP:UNPACKED AND SHIP:LOADED. WAIT 1. } GLOBAL c IS addons:camera:flightcamera. core:doevent("+CHAR(34)+"open terminal"+CHAR(34)+")." TO PATH("1:/startup.ks"). SET CORE:BOOTFILENAME TO "startup".
/me LOG "IF NOT SHIP:UNPACKED AND SHIP:LOADED { WAIT UNTIL SHIP:UNPACKED AND SHIP:LOADED. WAIT 1. } core:doevent("+CHAR(34)+"open terminal"+CHAR(34)+")." TO PATH("1:/startup.ks"). SET CORE:BOOTFILENAME TO "startup".

GLOBAL stage_check IS { LOCAL ns IS FALSE. IF STAGE:READY { IF MAXTHRUST = 0 { SET ns TO TRUE. } ELSE { LOCAL el IS LIST(). LIST ENGINES IN el. FOR e IN el { IF e:IGNITION AND e:FLAMEOUT { SET ns TO TRUE. BREAK. } } } IF ns	{ STAGE. } } ELSE { SET ns TO TRUE. } }.

IF HASNODE{UNTIL NOT HASNODE{REMOVE NEXTNODE. WAIT 0.}}
ADD NODE(TIME:SECONDS + 60,0,0,0).
UNTIL NEXTNODE:ORBIT:TRANSITION = "ENCOUNTER" { SET NEXTNODE:PROGRADE TO NEXTNODE:PROGRADE - 1. WAIT 0. }

LOCK THROTTLE TO NEXTNODE:DELTAV:MAG / (SHIP:MASS / SHIP:AVAILABLETHRUST).

/me ADD NODE(TIME:SECONDS + ETA:PERIAPSIS,0,0,SQRT(BODY:MU / (SHIP:ORBIT:PERIAPSIS + BODY:RADIUS)) - VELOCITYAT(SHIP,TIME:SECONDS + ETA:PERIAPSIS):ORBIT:MAG).
/me ADD NODE(TIME:SECONDS + ETA:APOAPSIS,0,0,SQRT(BODY:MU / (SHIP:ORBIT:APOAPSIS + BODY:RADIUS)) - VELOCITYAT(SHIP,TIME:SECONDS + ETA:APOAPSIS):ORBIT:MAG).

/me ADD NODE(TIME:SECONDS + ETA:APOAPSIS,0,0,0).
/me UNTIL NEXTNODE:ORBIT:APOAPSIS > MUN:APOAPSIS { SET NEXTNODE:PROGRADE TO NEXTNODE:PROGRADE + 1. }
/me UNTIL NEXTNODE:ORBIT:HASNEXTPATCH { SET NEXTNODE:ETA TO NEXTNODE:ETA + 1. }

ADD NODE(TIME:SECONDS + ETA:APOAPSIS,0,0,-10).

PRINT "relative Velocity: " + ROUND((VELOCITYAT(SHIP,14400 + TIME:SECONDS) - VELOCITYAT(TARGET,14400 + TIME:SECONDS)):MAG,2).

LOCK rt_vel TO SHIP:VELOCITY:ORBIT - TARGET:VELOCITY:ORBIT. LOCK STEERING TO -rt_vel.

LOCK THROTTLE TO (rt_vel):MAG / (SHIP:AVAILABLETHRUST / SHIP:MASS).
WHEN rt_vel:MAG < 0.01 THEN {LOCK THROTTLE TO 0.}

/me KUNIVERSE:TIMEWARP:WARPTO(TIME:SECONDS + NEXTNODE:ETA - burn_duration(345,(NEXTNODE:DELTAV / 1.5):MAG)).

/me WHEN NEXTNODE:ETA < burn_duration(345,(NEXTNODE:DELTAV / 2):MAG) THEN {LOCK THROTTLE TO NEXTNODE:DELTAV:MAG / (SHIP:AVAILABLETHRUST / SHIP:MASS).}
/me WHEN NEXTNODE:DELTAV:MAG < 0.1 THEN { LOCK THROTTLE TO 0. }
/me 

LOCK STEERING TO SHIP:SRFRETROGRADE.
WHEN SHIP:VERTICALSPEED > -10 THEN {LOCK STEERING TO -SHIP:VELOCITY:SURFACE  + SHIP:UP:FOREVECTOR * 10.}
LOCK localGrav TO BODY:MU / (BODY:POSITION - SHIP:POSITION):SQRMAGNITUDE.
LOCK shipAcc TO (SHIP:AVAILABLETHRUST / SHIP:MASS) * .95 - localGrav.
SET offSet TO 10.
LOCK vSpeedTar TO shipAcc * sqrt(2 * ABS(ALT:RADAR - offSet) / shipAcc) + 0.5.
LOCK minThrot TO (localGrav / shipAcc).
LOCK THROTTLE TO SHIP:VELOCITY:SURFACE:MAG - vSpeedTar + minThrot.
WHEN VANG(SHIP:VELOCITY:SURFACE,SHIP:UP:VECTOR) > 179 THEN { LOCK THROTTLE TO -SHIP:VERTICALSPEED - vSpeedTar + minThrot. }
WAIT UNTIL FALSE.

LIST ENGINES IN engList. PRINT "DV aprox: "  ROUND(engList[0]:ISP * 9.80665 * LN(SHIP:MASS / SHIP:DRYMASS)).

/me SET burn_duration TO { PARAMETER ISPs, DV IS NEXTNODE:DELTAV:MAG, wMass IS SHIP:MASS, sThrust IS SHIP:AVAILABLETHRUST. LOCAL dMass IS wMass / (CONSTANT:E^ (DV / (ISPs * 9.80665))). LOCAL flowRate IS sThrust / (ISPs * 9.80665). RETURN (wMass - dMass) / flowRate. }.
SET closeA TO { PARAMETER object1, object2, startTime IS TIME:SECONDS, scanTimeRange IS object1:ORBIT:PERIOD, scanSteps IS 32, minTime IS 1. LOCAL bestAproach IS (POSITIONAT(object1,startTime) - POSITIONAT(object2,startTime)):MAG.  LOCAL bestAproachTime IS startTime. UNTIL scanTimeRange < minTime { LOCAL strFrac IS scanTimeRange / scanSteps. LOCAL maxTime IS startTime + scanTimeRange. SET startTime TO startTime + strFrac / 2. FROM { LOCAL i IS startTime + strFrac. } UNTIL i >= maxTime STEP { SET i TO i + strFrac. } DO { LOCAL tmpAproach IS (POSITIONAT(object1,i) - POSITIONAT(object2,i)):MAG. IF tmpAproach < bestAproach { SET bestAproach TO tmpAproach. SET bestAproachTime TO i. } } SET startTime TO (bestAproachTime - (strFrac / 2)). SET scanTimeRange TO strFrac. } RETURN LEX("dist",bestAproach,"UTS",bestAproachTime). }.

LIST ENGINES IN engList. PRINT "aprox burn time: " ROUND((SHIP:MASS - (SHIP:MASS / (CONSTANT:E^ (NEXTNODE:DELTAV:MAG / (engList[0]:ISP * 9.80665))))) / (SHIP:AVAILABLETHRUST. / (engList[0]:ISP * 9.80665)),2).}

/me WHEN SHIP:ORBIT:HASNEXTPATCH AND (SHIP:ORBIT:NEXTPATCH:BODY = MUN) THEN {LOCK THROTTLE TO 0.}

IF HASNODE{UNTIL NOT HASNODE{REMOVE NEXTNODE. WAIT 0.}}
/me ADD NODE(TIME:SECONDS + 870,0,0,0).
/me UNTIL NEXTNODE:ORBIT:HASNEXTPATCH AND (NEXTNODE:ORBIT:NEXTPATCH:BODY = MUN) { SET NEXTNODE:ETA TO NEXTNODE:ETA + 1. }
/me when vang(SHIP:FACING:VECTOR, NEXTNODE:DELTAV > 90) THEN { LOCK THROTTLE TO 0. }
UNTIL NEXTNODE:ORBIT:NEXTPATCH:PERIAPSIS < 30000 AND NEXTNODE:ORBIT:NEXTPATCH:PERIAPSIS > 25000{ SET NEXTNODE:ETA TO NEXTNODE:ETA + 1. WAIT 0. }
UNTIL NEXTNODE:ORBIT:PERIAPSIS < 40000 { SET NEXTNODE:PROGRADE TO NEXTNODE:PROGRADE - 1. WAIT 0. }
PRINT NEXTNODE:ORBIT:PERIAPSIS.

LOCK THROTTLE TO 1. WHEN SHIP:ORBIT:NEXTPATCH:PERIAPSIS < 30000 THEN { LOCK THROTTLE TO 0. PRINT "PE below 30km".}

SET warp TO 5. WHEN SHIP:ALTITUDE < 500000000 THEN {SET warp TO 0. }

/me SET fairing TO SHIP:PARTSDUBBEDPATTERN("shell")[0]:GETMODULE("moduleproceduralfairing"):DOEVENT("deploy"). PRINT fairing[0]:GETMODULE("moduleproceduralfairing"):ALLEVENTS.
fairing[0].


/me GLOBAL rgb_gen IS { PARAMETER maxVal,val. LOCAL result IS MOD(val,maxVal) / maxVal * 3. LOCAL re IS MAX(MIN(1 - result,1),0). LOCAL gr IS 0. LOCAL bl IS MAX(MIN(result,1),0). IF result > 1 { SET bl TO MAX(MIN(2 - result,1),0). SET gr TO MAX(MIN(result - 1,1),0). IF result > 2 { SET gr TO MAX(MIN(3 - result,1),0). SET re TO MAX(MIN(result - 2,1),0). } } RETURN RGBA(re,gr,bl,2). }.
GLOBAL colorCount IS 0. GLOBAL hlIndex IS 0. GLOBAL nugHLlist IS LIST(). FOR par IN SHIP:PARTS { nugHLlist:ADD(HIGHLIGHT(par,rgb_gen:CALL(768,0))).} FOR hl IN nugHLlist {SET hl:ENABLED TO TRUE.}
GLOBAL nugLive IS TRUE. WHEN TRUE THEN { SET colorCount TO MOD(colorCount + 1,768). SET hlIndex TO MOD(hlIndex + 1,nugHLlist:LENGTH). SET nugHLlist[hlIndex]:COLOR TO rgb_gen:CALL(768,colorCount). IF nugLive {PRESERVE.} ELSE { FOR hl IN nugHLlist {SET hl:ENABLED TO FALSE. }}}
